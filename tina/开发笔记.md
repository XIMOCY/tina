# 开发笔记
里面包含了我对整个项目的开发过程的一些记录。
1. 整个项目原理
2. 模型调用和部署
3. 工具方面的设计
4. 记忆模块的设计
5. RAG的实现
6. 智能体的设计
7. 用上工具写一个demo

# 1. 整个项目原理
` 关于下面的一系列问题，都可以在Kimi的api文档找到答案，推荐去读一下 `\
[Moonshot AI 开放平台](https://platform.moonshot.cn/docs)
## 一.大模型的记忆是怎么一回事？
模型是没有记住和你对话数据能力的，它拥有的记忆是训练数据的培养的对话能力，关于这点可以去看Kimi的api文档，里面有清楚的解释:\
[使用 Kimi API 进行多轮对话](https://platform.moonshot.cn/docs/guide/engage-in-multi-turn-conversations-using-kimi-api)\
大模型的记忆机制并不是传统意义上的记忆，比如像人类那样能够记住具体的事件或者对话内容。相反，它们依赖于训练过程中所学到的模式和信息来生成回应。这意味着模型本身并不会“记住”与你的特定对话；它每次生成回复时，都是基于输入的信息以及它在训练阶段学到的知识。

然而，在实际应用中为了实现多轮对话的连贯性，系统通常会将之前的对话历史作为上下文的一部分传递给模型。这样做的目的是让模型可以参考你之前的问题或陈述，从而提供更加相关和连贯的回答。例如：

假设你在之前的对话中提到你喜欢阅读科幻小说，并询问了关于某部作品的看法。如果你接下来问：“那你觉得我应该看看哪位作家的作品？” 系统会把前面对话中的偏好信息（即你喜欢科幻小说）包含在内，使模型可以根据这些信息给出更贴合你兴趣的回答。

如果你想实现一个简单的多轮对话的实现，参考上面我给的Kimi团队的文档吧
## 二.大模型是怎么调用工具的？
[什么是工具调用-tool_calls-Kimi](https://platform.moonshot.cn/docs/guide/use-kimi-api-to-complete-tool-calls#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8-tool_calls)

大模型调用工具的过程可以理解为模型在需要执行某些特定任务时，借助外部工具来完成。这些工具可以是搜索引擎、数据库、计算器等，模型通过调用这些工具来获取信息或执行操作。

举个例子，如果你问模型“今天的天气怎么样？”，模型本身并不知道实时天气情况，但它可以调用一个天气查询工具，获取当前天气数据，然后生成回答。

这个过程通常分为几个步骤：

1. **识别需求**：模型分析用户的问题，判断是否需要调用工具。
2. **选择工具**：根据需求选择合适的工具。
3. **调用工具**：模型生成调用工具的指令，并发送给工具。
4. **获取结果**：工具执行任务并返回结果。
5. **生成回答**：模型根据工具返回的结果，生成最终的回答。

### 大模型如何知道有工具的

在实现方面，大模型是如何知道有工具，并且可以调用它的呢？这涉及到工具传递的规范。如果有过API使用经验的开发者应该清楚，API的请求数据中有一个请求键叫做`tools`，这个`tools`要求上传一个列表，里面是符合特定JSON Schema的数据。

#### 工具传递的格式

在代码中，工具的信息是通过一个 JSON Schema 来描述的。具体来说，每个工具的信息包含以下几个部分：

- **工具类型（type）**：通常为 "function"，表示这是一个函数工具。
- **函数信息（function）**：
  - **名称（name）**：工具的名称，用于标识工具。
  - **描述（description）**：工具的功能描述，帮助大模型理解工具的用途。
  - **参数（parameters）**：
    - **类型（type）**：通常为 "object"，表示参数是一个对象。
    - **必需参数（required）**：列出必须传递的参数名称。
    - **属性（properties）**：描述每个参数的详细信息，包括参数的类型和描述。

#### 工具传递的格式的示例

假设我们有一个工具叫做 `getTime`，它的作用是获取当前时间。这个工具的信息可以这样描述：

```json
{
    "type": "function",
    "function": {
        "name": "getTime",
        "description": "获取当前时间",
        "parameters": {
            "type": "object",
            "required": [],
            "properties": {}
        }
    }
}
```

在这个例子中，`getTime` 工具不需要任何参数，所以 `required` 和 `properties` 都是空的。

再比如，另一个工具 `query` 用于在文档中查询信息，它需要一个 `query_text` 参数和一个可选的 `n` 参数：

```json
{
    "type": "function",
    "function": {
        "name": "query",
        "description": "使用该工具可以在用户的文档里面查询有关信息",
        "parameters": {
            "type": "object",
            "required": ["query_text"],
            "properties": {
                "query_text": {
                    "type": "str",
                    "description": "要查询的文本"
                },
                "n": {
                    "type": "int",
                    "description": "返回的结果数量,默认为10"
                }
            }
        }
    }
}
```

在这个例子中，`query` 工具需要一个 `query_text` 参数，并且可以接受一个可选的 `n` 参数。

知道了这个规范后，大模型会根据工具的描述和参数的描述来决定是否使用该工具。通过这种方式，大模型能够灵活地调用各种外部工具，从而完成更复杂的任务。

下面是一个例子，读者可以模仿
```json
[
    {
    "type": "function",
    "function": {
        "name": "getTime",
        "description": "获取当前时间",
        "parameters": {
            "type": "object",
            "required": [],
            "properties": {}
        }
    }
},
{
    "type": "function",
    "function": {
        "name": "getWeather",
        "description": "获取指定城市的当前天气情况",
        "parameters": {
            "type": "object",
            "required": ["city"],
            "properties": {
                "city": {
                    "type": "string",
                    "description": "城市名称"
                }
            }
        }
    }
},
{
    "type": "function",
    "function": {
        "name": "queryDocument",
        "description": "在用户的文档中查询相关信息",
        "parameters": {
            "type": "object",
            "required": ["query_text"],
            "properties": {
                "query_text": {
                    "type": "string",
                    "description": "要查询的文本"
                },
                "n": {
                    "type": "integer",
                    "description": "返回的结果数量,默认为10"
                }
            }
        }
    }
}

]
```
### 大模型如何执行工具调用

大模型本身并不直接支持调用工具，但它可以生成工具调用的指令。这些指令遵循特定的格式，模型通过输出这些指令来间接调用外部工具。工具调用通常用于执行一些模型无法直接完成的任务，比如查询实时数据、进行计算或访问外部资源。

#### 工具调用指令的格式

大模型生成的工具调用指令通常是一个 JSON 格式的字符串，包含工具的名称和所需的参数。具体格式如下：

```json
{
    "name": "工具的名字",
    "arguments": {
        "参数1": "值1",
        "参数2": "值2"
    }
}
```

例如，如果模型需要调用一个名为 `query` 的工具来查询信息，它可能会生成如下指令：

```json
{
    "name": "query",
    "arguments": {
        "query_text": "和人工智能技术有关的信息",
        "n": 10
    }
}
```

#### 本地模型的工具调用处理

对于本地模型，工具调用指令通常会被输出为一个字符串，嵌入在模型的响应中。这个字符串可以通过正则表达式提取出来，然后使用 `json.loads()` 将其转换为 Python 字典。以下是一个示例：

```python
import re
import json

# 假设模型输出的工具调用指令嵌入在以下字符串中
response = "...'<tool_call>\n{{'name': 'query','arguments': {'query_text': '和人工智能技术有关的信息', 'n': 10}}}\n</tool_call>'..."

# 使用正则表达式提取工具调用指令
tool_call_str = re.search(r'<tool_call>(.*?)</tool_call>', response).group(1)

# 将字符串转换为字典
tool_call = json.loads(tool_call_str)

# 根据工具名称调用相应的工具
if tool_call["name"] == "query":
    query(**tool_call["arguments"])
elif tool_call["name"] == "another_tool":
    another_tool(**tool_call["arguments"])
```

在这个示例中，`query` 和 `another_tool` 是预先定义好的工具函数，`**tool_call["arguments"]` 将字典中的参数传递给这些函数。

#### API 调用模型的工具调用处理

对于通过 API 调用的模型，工具调用指令通常会包含在 API 的返回结果中。你可以通过检查返回结果中的 `tool_calls` 字段来判断是否有工具调用指令。以下是一个示例：

```python
# 假设 result 是 API 返回的结果
result = API()

# 检查是否有工具调用指令
if "tool_calls" in result:
    tool_call = result["tool_calls"][0]["function"]
    
    # 根据工具名称调用相应的工具
    if tool_call["name"] == "query":
        query(**tool_call["arguments"])
    elif tool_call["name"] == "another_tool":
        another_tool(**tool_call["arguments"])
```

在这个示例中，`API()` 是一个模拟的 API 调用函数，`result["tool_calls"][0]["function"]` 提取了第一个工具调用指令，然后根据工具名称调用相应的工具。
